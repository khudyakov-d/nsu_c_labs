Z2exi:
        push    {r4, r5, fp, lr} //заносим на стек значения регистров r4, r5
								//fp(r11)
								//lr(r14) - адрес возврата из процедуры 
        add     fp, sp, #12  // fp = sp + 12 
							// sp - указатель на вершину стека
        sub     sp, sp, #32 // sp = sp - 32
        str     r0, [fp, #-40] // загружаем в fp - 40 r0 ( x = 10 )
        mov     r3, #0 // r3 = 0 
        ldr     r4, .L5//  r4 = L5 (1072693248)
        str     r3, [fp, #-28] // кладем в fp-28 r3 
        str     r4, [fp, #-24] // кладем в fp-24 r4 (double exVal = 1 )
        mov     r3, #0 // r3 = 0 
        ldr     r4, .L5 // r3 = L5 (1072693248)
        str     r3, [fp, #-36] // кладем в fp-36 r3
        str     r4, [fp, #-32] // кладем в fp-32 r4 (double el = 1 )
        mov     r3, #1 // r3 = 1 
        str     r3, [fp, #-16] // кладем в fp-16 r3 (size_t i = 1)
.L3:
        ldr     r3, [fp, #-16] // выгружаем из fp - 16 в r3
        ldr     r2, .L5+4 // r2 = L5 + 4 (499999999) 
        cmp     r3, r2 //сравниваем i и N-1 и продолжаем , если r3<r2
        bhi     .L2 //иначе переходим по метке
        ldr     r0, [fp, #-40]	// загружаем в r0 значение по адресу f - 40 ( x = 10 )
        bl      __aeabi_i2d  // переводим r0(x) в double старшие разряды в r0 
							// младшие в r1 
        sub     r3, fp, #36 // sp = fp - 36
        ldmia   r3, {r2-r3} // снимаем el старшие разряды в r2
							// младшие в r3
        bl      __aeabi_dmul // перемножаем x и el ч/з r0,r1 и r2,r3
							//записываем результат в r0,r1 
        mov     r3, r0 // r3 = r0
        mov     r4, r1 // r1 = r1
        mov     r5, r4 // r5 = r4
        mov     r4, r3 // r3 = r3
        ldr     r0, [fp, #-16] // выгружаем из fp - 16 r0
        bl      __aeabi_ui2d // переводим i в double старшие разряды в r0 
							// младшие в r1 
        mov     r2, r0 // r2 = r0	
        mov     r3, r1 // r3 = r1
        mov     r0, r4 // r0 = r4
        mov     r1, r5 // r1 = r5
        bl      __aeabi_ddiv // делим x*el на i ( r0,r1 на r2, r3)
							//записываем результат в r0, r1
        mov     r3, r0	// r3 = r0
        mov     r4, r1 // r4 = r1
        // запись результата выражения на место el
        str     r3, [fp, #-36] записываем по адресу fp-36 r3
        str     r4, [fp, #-32] записываем по адресу fp-32 r4
        sub     r3, fp, #36 // r3 = fp - 36
        ldmia   r3, {r2-r3} // снимаем со стека результат x*el/i
							// записываем в r2,r3
        sub     r1, fp, #28 // r1 = fp - 28
        ldmia   r1, {r0-r1} // снимаем со стека exVal
							// записываем в r0,r1
        bl      __aeabi_dadd // складываем r0,r1 и r2,r3
							//кладем результа в r0,r1
        mov     r3, r0 //r3 = r0
        mov     r4, r1 //r4 = r1
        
        // запись результата выражения на место exVal
        str     r3, [fp, #-28] записываем по адресу fp-28 r3
        str     r4, [fp, #-24] записываем по адресу fp-24 r4
        ldr     r3, [fp, #-16] выгружаем в r3 значение по адресу fp - 16 (i)
        add     r3, r3, #1 // i += 1 
        str     r3, [fp, #-16] записываем по адресу fp-16 r3
        b       .L3 // переходим в начало метки
.L2:
        sub     r4, fp, #28 // r4 = fp - 28
        ldmia   r4, {r3-r4} // загружаем в регистр r3 младшие биты exVal
							// в r4 старшие биты
        mov     r0, r3 //загружаем в r0 значение r3
        mov     r1, r4 //загружаем в r0 значение r3
        sub     sp, fp, #12 // sp = fp - 12
        pop     {r4, r5, fp, lr} // читаем в lr - адрес возврата 
								// в fp - указатель на начало фрейма перед входом в функцию
								// читаем в r4 , r5 что-то ( там ничего не лежало)
        bx      lr // возвращаемся в функцию
.L5:
        .word   1072693248
        .word   499999999
main:
        push    {fp, lr} 	//заносим на стек fp(r11) 
							//lr(r14) - адрес возврата из процедуры 
        //sp - указатель на вершину стека
        add     fp, sp, #4 // fp = sp + 4
        sub     sp, sp, #16 //sp = sp - 16 
        mov     r3, #10 // r3 = 10 
        str     r3, [fp, #-8]  записать по адресу fp - 8 (sp - 4) значение r3 ( x = 10 )  
        ldr     r0, [fp, #-8]  загрузить в r0 значение r3
        bl      _Z2exi //переход по метке с сохранением адреса возврата 
        //записываем в ex результат 
        str     r0, [fp, #-20] // загружаем в fp - 20 r0
        str     r1, [fp, #-16] // загружаем в fp - 16 r1
        mov     r3, #0 //записать в r3 0
        mov     r0, r3// r0 = r3
        sub     sp, fp, #4 // sp = fp - 4
        pop     {fp, lr} // снимаем со стека fp и lr 
        bx      lr //возвращаем lr
